# Assembly
#### ※ C언어가 바탕으로 되어있어야 합니다.

어셈블리어는 하드웨어와 가까운 언어로 CPU가 알아듣기 쉽게 만들어진 언어입니다.<br/>
그리고 저는 올리디버거를 사용하여 디버깅한 것을 바탕으로 작성할 것입니다. 
<br/>

> - 레지스터
>   - 범용레지스터
>   - 상태 레지스터
> - 명령어
>   - 기본적인 사용방법
>   - 응용
> - 짜투리 이론

- - -

## 레지스터
- CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
- CPU가 처리 중인 데이터를 저장
  (메모리는 프로그램 실행에 필요한 데이터를 저장)
 <br/><br/>

### 범용 레지스터
##### ※순서는 올리디버거 기준
> - 데이터 저장<br>
> **EAX**ㅤ:ㅤ주로 산술연산의 결과를 저장하는 데 사용, 피연산자로도 사용<br/>
> **ECX**ㅤ:ㅤ반복 명령어 사용 시 반복한 카운트 값을 저장<br/>
> **EDX**ㅤ:ㅤ크기가 큰 수의 곱ㆍ나눗셈에서 EAX와 함께 사용(+부호 확장)<br/>
> **EBX**ㅤ:ㅤESI, EDI 레지스터와 결합될 수 있고, 메모리 주소를 저장<br/>



> - 주소 저장<br/>
> **ESP**ㅤ:ㅤ스택프레임의 스택 가장 끝 지점 주소 저장(값이 ±4byte씩 이동<br/>
> **EBP**ㅤ:ㅤ스택프레임의 스택 시작 지점 주소 지정(스택프레임 소멸이 아니면 값 변동 X)<br/>-> 현재 스택프레임이 소멸되면 이전 스택프레임의 시작 지점 주소 저장<br/>
> **ESI**ㅤ:ㅤ데이터 조작, 복사 시 소스데이터 주소 저장(EDI에 데이터를 넘길 때 주로 사용)<br/>
> **EDI**ㅤ:ㅤ복사 시 목적지의 주소가 저장되는데 주로 ESI가 가르키는 주소 저장<br/> 


### 상태 레지스터
> - [ **Flag** ]<br/>
> **C**ㅤ:ㅤ부호가 없는 연산의 결과가 비트 범위를 넘어섰을 때 참으로 설정<br/>
> **P**ㅤ:ㅤ연산 결과에 1로 된 비트의 수가 짝수일 경우 참으로 설정<br/>
> -> intel CPU에서는 홀수 패리티 방식을 쓰기 때문에 1로 된 비트 수를 맞춤<br/>
> **A**ㅤ:ㅤ연산에서 하위 4bit에 자리올림이 발생하면 참으로 설정<br/>
> **Z**ㅤ:ㅤ연산 결과가 0일 경우 참으로 설정<br/>
> **S**ㅤ:ㅤ연산 결과가 음수일 경우 참으로 설정<br/>
> **T**ㅤ:ㅤ디버깅 시에 사용되는 플래그로 지금은 건너 뜀<br/>
> **D**ㅤ:ㅤ문자열 조작에서 참일 경우 자동감소 거짓일 경우 자동증가<br/>
> -> 변환 되는 값은 주소레지스터 값<br/>
> **O**ㅤ:ㅤ부호가 있는 연산을 할 때, 언더 or 오버플로우가 발생하면 참으로 설정

### 그 외
> **ESI**ㅤ:ㅤ다음 실행할 명령어가 있는 주소 저장
- - -
## 명령어
### 기본적인 명령어

> - [ **MOV** ]<br/>
> moveㅤ:ㅤ레지스터나 메모리에 값을 덮어 씌우는 명령어<br/>
> 메모리 -> 메모리를 제외한 연산이 가능하고, 메모리는 []로 주소지정<br/>
> 아래 형식으로 작성되고, 즉시 값은 16진수로 작성<br/>
>```
> mov reg/mem, (즉시 값)
>```



> - [ **NOP** ]<br/>
> No OPerationㅤ:ㅤ작동하지 않음<br/>

> - [ **JMP** ]<br/>
> jumpㅤ:ㅤ원하는 주소로 건너뛰기<br/>
> 현재 주소가 40100F라고 했을 때 jmp 401005를 실행하면 ESI는 다음 번지인 401011을<br/>
> 저장하는데 명령어 옆에 보면 EB F4를 볼 수 있는데 기계어로 F4만큼 뺀다는 의미<br/>
> F4 -(2진수)-> 11110100 -(부호가 있는 16진수)-> -C로 표현 할 수 있고,<br/>
> 401011 - C 라고 표현할 수 있다. 그래서 결론은 401005의 주소를 가르키는 형식

> - [ **증감연산** ]<br/>
>> - [ **INC, DEC** ]<br/>
>>   INCREMENTㅤ:ㅤ1씩 값 증가<br/>
>>   DECREMENTㅤ:ㅤ1씩 값 감소<br/>
>>```
> >inc reg/mem | dec reg/mem
>>```
>
>>   - [ **ADD, SUB** ]<br/>
>>   ADDITIONㅤ:ㅤ더하기<br/>
>>   SUBTRATIONㅤ:ㅤ빼기<br/>
>>```
>> add reg/mem, reg/mem | sub reg/mem, reg/mem
>>```
>>
>ㅤ

> - [ **CMP** ]<br/>
> compareㅤ:ㅤA와 B의 값을 빼기 연산으로 같은지 비교
>```
> com A, B
>```

> - [ **J명령어 모음** ]<br/>
> ##### ※jmp_flag.txt 참조
> jmp에 조건이 있는 명령어들로 C 언어에서는 if같은 조건식이 되는 명령어들<br/>
>   - [ **JZ ( JE )** ]<br/>
> jump if zero( jump if equal)ㅤ:ㅤz값이 1일 경우 이동<br/>
> 조건식ㅤ:ㅤa == b
>   - [ **JNZ ( JNE )** ]<br/>
> jump if not zero( jump if not equal)ㅤ:ㅤz값이 0일 경우 이동<br/>
> 조건식ㅤ:ㅤa != b
>   - [ **JA, JB** ]<br/>
> jump if [ above, below ]ㅤ:ㅤja는 c값이 1일 때, jb는 c 이 0일 때 이동 + ( z = 0 )<br/>
> 조건식ㅤ:ㅤa > b | a < b
>   - [ **JEA, JEB** ]<br/>
> jump if equal [ above, below ]ㅤ:ㅤjea는 c값이 1일 때, jeb는 c값이 0일 때 이동<br/>
> 조건식ㅤ:ㅤa >= b | a <= b
>   - [ **JNA, JNB** ]<br/>
> jump if not [ above, below ]ㅤ:ㅤja는 c값이 0일 때, jb는 c값이 1일 때 이동<br/>
> 조건식ㅤ:ㅤa <= b | a >= b
>   - [ **JG, JL** ]<br/>
> jump if [ greater, less ]ㅤ:ㅤjg는 s값과 c값이 같을 때, jl은 다를 때 이동 + ( z = 0 )
>   - [ ** ** ]

- - -
## 짜투리 이론
> - **레지스터 구성**<br/>
> 레지스터는 32bit CPU에서 EAX, AX, AH, AL로 구성<br/>
> EAX의 하위 4byte가 AX, AX의 상위 2byte가 AH, 하위 2byte가 AL

> - **짜투리 문법**<br/>
> [DWORD, WORD, BYTE] PTR DS<br/>
>   - **Memory unit**<br/>
>     DWORD = 4byte WORD=2byte BYTE=1byte (+QWORD = 8byte : 64bit에서 씀)<br/>
>   - **Segment** 레지스터지만 메모리 할당부분이라 따로 씀 <br/> 
>     CS:코드 영역, DS : 데이터 영역, ES :여분, SS : 세팅 영역, FS, GS,

> - **Byte Ordering**
>   - Big Endianㅤ:ㅤ메모리 주소가 낮은 자리 수부터 큰 값을 저장<br/>
>   ex) 12345678 -> 12345678<br/>
>   장점ㅤ:ㅤ사람이 읽고 쓰기에 편함
> 
>   - Little Endianㅤ: 메모리 주소가 높은 자리 수부터 큰 값을 저장<br/>
>   ex) 12345678 -> 78563412<br/>
>   장점ㅤ:ㅤ기계가 읽고 쓰기에 편함(하위 바이트 사용 시에 편함)

>  - [ **간접 주소 지정** ]<br/>
> 간접 주소 지정 방식을 쓰는 이유는 메모리 주소를 지정하는 []를 한 명령어에<br/>
> 두 번 이상 쓸 수 없기 때문(메모리에서 메모리로 데이터 전달 불가)
>```
> mov eax, 402000
> mov [eax], 1
>```
> - offsetㅤ:ㅤ처음 주어진 요소나 지점까지의 변위차를 나타내는 정수(상대 주소)<br/>
> []로 간접 주소 지정  방식을 사용할 때는 최대 2개의 레지스터를 쓸 수 있고, 그 중<br/>
> index는 레지스터가 무조건 들어가야하고, scale은 자료형의 크기(byte)를 지정
> ```
> [ base + offset + index * scale]
> ```
>> - [ **응용** ]<br/>
>> 간접 주소 지정 방식을 사용하는 방법
>>> - [ **Pointer** ]<br/>
>>>```c
>>>   int a = 0;
>>>   int *p = &a;
>>>   *p = 4;
>>>```
>>> C 언어에서 위처럼 작성했다면, 어셈블리어에서는<br/>
>>>```
>>>   mov dword ptr [402000], 0
>>>   mov dword ptr [402004], 402000
>>>   mov ebx, [402004]
>>>   mov dword ptr [ebx], 4
>>>```
>>> 로 작성, 메모리 402000번지를 변수 a처럼 두고, *p에 a의 주소를 지정하는 것처럼 <br/>
>>> 402004번지에 402000을 넣고, ebx에 402004를 저장한 뒤에 [ebx] 즉, [402004]번지에<br/>
>>> 4를 저장 ( 마지막을 mov [[402004라고 보면 됨]] )
>>
>>> - [ **Aray** ]<br>
>>> ```c
>>>   int a[3];
>>>   a[0] = 0;
>>>   a[1] = 1;
>>>   a[2] = 2;
>>> ```
>>> 역시나 C 언어에서 위처럼 작성했다면, 어셈블리어에서는
>>>```
>>>   mov ebx, 402000
>>>   mov byte ptr [ebx], 0
>>>   mov byte ptr [ebx+1], 1
>>>   mov byte ptr [ebx+2], 2
>>>```
>>> 이런 식으로 ebx를 고정 주소로 하고 offset을 1씩 늘려가며 배열을 선언<br/>
>>> 자료형이 int일 경우 index * scale을 지정<br>
>>>
>>> 배열을 선언하는 다른 방법으로는
>>>```
>>>   mov ebx, 0
>>>   mov byte ptr [ebx+402000], 0
>>>   inc ebx
>>>   mov byte ptr [ebx,402000], 0
>>>```
>>> 이런 식으로 offset을 고정으로 ebx값을 늘려나가는 방법이 있다.<br/>
>>> 물론 위에 방식도 increment로 1씩 늘릴 수 있다.<br/>
>>> 이 경우에 int형은 move dword ptr [ebx*4+402000]으로 표현
>> 
>> ㅤ
>
>ㅤ