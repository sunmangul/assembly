[어셈블리어]
C가 기본으로 되어야함, 어셈블리어는 하드웨어와 가장 가까운 언어로 CPU가 알아먹을 수
있는 언어로 적는 언어, 많은 디버거가 있겠지만 올리디버거를 사용하려 함

[mov]
mov : 값을 덮어씨움
ex) mov reg,(즉시 값)   /   mov reg,reg
입력한 값 또는 다른 레지스터의 값을 레지스터에 덮어 씌움
주소를 넣을 때는 16진수로 들어감 (8자리 4(byte))

[레지스터]
AX : 8(bit)공간 두개
>>AH : 자릿수가 큰쪽 바이트, AL : 자릿수가 작은쪽 바이트

EAX : 8(bit)공간 네개
>>낮은 자리쪽 두 바이트가 AX
그 AX안에서 AH, AL이 똑같이 있음
ex) mov eax, 12D687
AX : D687 | AH : D6 | AL : 87A

E[A,B,C,D]X | [A,B,C,D]X | [A,B,C,D]H | [A,B,C,D]L
요런 것들이 있음

mov 명령어에서 CH와 같이 특정 바이트를 지정해서 값을 넣을 수 있음

[램(RAM)] - 주기억장치
┌───────────┐ ┌─┐                  ┌───────────────┐
│    CPU    │ │R│                  │               │
└───────────┘ │A│                  │               │
              │M│                  │    HARDDISK   │
              └─┘                  │               │
                ┌─┐________________│               │
                └─┘                └───────────────┘
용량 CPU < RAM < HARDDISK
속도 CPU > RAM > HARDDISK
가격 CPU > RAM > HARDDISK

메모리(램)을 주기억장치로 쓰는 이유는 CPU는 잠깐 생각(연산)을 담당하며 하드디스크는
기억한 자료들이 다 저장되긴 하지만 찾아볼 부분이 너무 많아 느림
기억 = CPU, 쪽지 = RAM, 책 = HARDDISK  

[RAM & ROM]
RAM : 읽고 쓰기가 가능한 메모리로 회로 변경이 가능
ROM : 한 번 만들면 회로 변경이 불가능하고 읽는 것만 가능
연결 = 1, 끊김 = 0으로 놓았을 때
    ┌────────────────────┐
   ┌┴─┐                  │
 ┌─┴──┴─┐                │
 │      │          ┌─────┴─────┐
 │      │          │           │
 │      │          │    CPU    │
 │      │          │           │
 │      │          └─────┬┬────┘
 │      │                ││
 └──┬┬──┘                ││
    │└───────────────────┘│
    └───────━   ━─────────┘
와 같이 자릿수에 따라 입력이 가능한데 연결을 끊어[전기 신호를 안줘]서 0을 넣음
이렇게 메모리의 용량을 늘리는데 용량을 늘릴수록 전선의 양이 매우 많이 필요함
(+메모리 핀이 부족함)
이렇기 때문에 주소를 이용하여 값을 전달함(스위치를 이용하여 찾아갈 주소를 지정)
      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0 0 1 0 1
└─────┬┬────┘              │
      │└──────────┐        │
     ┌┴─┐         │        │
   ┌─┴──┴─┐       │        └┐
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 아래 주소만 입력

      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0│0 1 0 1
└─────┬┬────┘              ││
      │└──────────┐         │
     ┌┴─┐         │         │
   ┌─┴──┴─┐       │         │
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 위에 주소만 입력

메모리는 주소하나에 한 바이트의 데이터가 들어가도록 시스템이 설계됨
인텔 32비트 컴퓨터에서는 주소값을 32비트로 표현 가능
=한 바이트를 설정할 수 있는 스위치가 32개 있다=경우의 수 2^32개
=>4GB의 메모리 공간 사용  

[]안에 주소를 써서 메모리 공간 지정(16진수)
mov [402000], al >> MOV BYTE PTR DS:[402000], AL이 됨 -(실행)-> 402000주소 번지에 AL의 값이 들어감
mov cl, [402000] >> MOV AL, BYTE PTR DS:[402000]이 됨 -(실행)-> CL에 402000주소 번지의 값이 들어감
이런식으로 메모리 안에 값을 넣거나 메모리의 값을 레지스터에 넣을 수 있으나 메모리에서 메모리로는 X

= 레지스터에 메모리의 값을 임의로 넣어두고 다른 메모리에 값을 넣어야 함

[잡다한 문법]
DWORD PTR DS, WORD PTR DS, BYTE PTR DS
cs:코드 영역, ds : 데이터 영역, es :여분, fs, gs, ss : 세팅 영역
ptr = pointer
DWORD = 4byte WORD=2byte BYTE=1byte (+QWORD = 8byte : 64bit에서 씀)
WORD면 32bit 기본인 4byte가 아닌 이유는 16bit 때부터 써오던 표기라 그대로 2byte로 쓰고, double word인
DWORD라는 4byte 공간이 있음

메모리 지정은 자동이지만 약간 귀찮은 느낌이 있음
ex) 8자리 값(12345678)을 지정할 때, 주소를 2000으로 하면 2007번지부터 12 34 56 78로 들어가서
78 56 34 12로 표기 됨 = 보기 뭔가 이상함

No OPeration(NOP) : 작동하지 않음 = pass

메모리에 레지스터의 값을 넣는게 아니라 직접 넣어줄 때는 메모리 크기 지정이 자동이 아니라 수동으로 해줘야함
만약 402000으로 부터 8자리가 채워져 있었을 경우 mov dword ptr ds:[402000], 0을 해주면
8자리에 0을 채움으로써 앞에 넣었던 값을 모두 0으로 덮어씀

[Byte Ordering [Big Endian/ Little Endian]]
Intel은 한 바이트에 하나의 값을 지정하는 형식을 가지고 있다.
Endian은 하드웨어의 구조, 하드웨어의 설계를 말하는데 데이터 저장 순서에 따라 나뉨
00 01 01 00를 입력을 했을 때
Little Endian의 경우 낮은 자리 수 부터 저장하여 00101000으로 저장됨
Big Endian의 경우 큰 자리 수 부터 저장하여 00010100으로 저장된다.
ex) 3456을 2진수로 바꾸면 0011 0100 0101 0110이고 이것을 낮은 자리 수부터 넣으면
0110 1010 0010 1100 이런식으로 저장됨
메모리는 항상 낮은 자리에서 높은 자리로 실행
읽는다 = 메모리의 데이터를 레지스터로 옮김
Big Endian은 메모리에 적힌 값을 앞에서부터 읽어 높은 자리수에 순서대로 넣음
Little Endian의 경우 맨 앞의 값이 낮은 자리이기 때문에 낮은 자리수부터 넣음
※주소와 자리수를 햇갈리면 안됨

ex) Big Endian 0011010001010110 -> 0011010001010110
 Little Endian 0101011000110100 -> 0011010001010110

그리고 Little Endian 방식으로 저장을 하고 한 바이트씩 끊어 읽기 때문에
01101010/00101100 -> 01010110/00110100 -(10진수)-> 56/34로 메모리에 들어감

Endian 방식은 메모리에 적히는 건 다르지만 읽히고 난 값은 같음

장점 :
Little Endian은 한 바이트씩 기계가 읽기 편하고, 값이 앞에 들어갈 때 메모리 뒤쪽에
써주면 되서 편함
ex) 1234 저장 3412 -> 4321 앞에 추가 34122143 이런식으로 앞에 값이 추가되도
뒤에 넣기 편함 (CPU한테 유리)

Big Endian은 사람이 읽기 편함

[jmp]
jmp : 원하는 주소로 앞이든 뒤든 건너뛰기 가능
EIP : 실행할 곳의 주소를 담고 있는 레지스터(범용 레지스터가 아니라서 mov 사용 안됨)
>> jmp를 이용하여 바꾸게 됨

┌───────────┐ ┌─┐
│401000 EIP │ │R│
└───────────┘ │A│
              │M│
              └─┘ 
401000을 RAM에 넘겨줌 그럼 램은 B8 00000000을 읽어옴 -> 읽어온 바이트만큼 주소값 증가
401005가 되고 한번 더 읽으면 40100A, 40100F 이런식으로 계속 읽어옴
이때 jmp 401005를 실행하면 EB F4를 읽어옴 현재 40100F라고 했을 때, 401011이 됨 그리고
EB F4를 실행되고 입력한 값인 401005번지로 이동하게 된다.
F4 -(2진수)-> 11110100 -(부호가 있는 16진수)-> -C
401011 -C = 401005

-128 ~ +127의 거리를 이동할때는 short이 붙지만 그 이상일 때는 long을 씀

jmp eax와 같은 명령어를 실행할 때는 eax값이 유효한 번지의 값이어야하고
ax처럼 2byte값으로 점프를 하면 메모리에 할당 된 값이 아니라 오류가 생기고 종료됨
메모리 값에 주소를 지정하고 그 메모리 값을 참조하여 점프하는 것도 가능
ex) MOV DWORD PTR DS:[402000],00401015
    JMP DWORD PTR DS:[402000]

[증감 연산]
드디어 증감 연산이 나옴
increment(inc) : 증가
decrement(dec) : 감소
ex) inc reg/mem, dec reg/mem
지정해준 레지스터나 메모리의 값이 1씩 증감

addition(add) : 더하기
subtraction(sub) : 빼기
ex) add a, 10 & sub a, 10 (10진수 십이 아니라 16진수 일영임)
add reg/meme, reg/meme & sub reg/mem, reg/mem

[간접주소지정]
mov eax, 402000   //eax에 402000이란 값을 넣음
mov [eax], 0      //[]는 메모리 지정 방식임 거기에 eax가 들어오니까 레지스터의 값에
있는 메모리 주소를 가져옴
혹은
mov dword ptf [402000], 402004
이와 같은 방법을 쓰는 이유는 메모리간 데이터 이동이 불가능하기 때문에 주소를
데이터 형태로 지정하여 이동

offset : 처음 주어진 요소나 지점까지의 변위칠를 나타내는 정수(상대주소)
[고정주소 + 상대주소 + index * scale] 이런식으로도 쓸 수 있고 오프셋 가장 기본은
[고정주소 + 상대주소]같은 형식
여기에 들어갈 수 있는 최대 레지스터는 2개고 index는 반드시 레지스터여야함
scale은 자료형을 나타내는 것으로 int형(4byte)일 경우 scale은 4같은 형식

┌──────────────────┬────────────────────────────────────────────┐
│        C         │                  Assembly                  │
├──────────────────┼────────────────────────────────────────────┤
│char a[6] = 0;    │mov ebx, 402000                             │
│a[0]=0;           │mov byte ptr [ebx],0                        │
│a[1]=1;           │mov byte ptr [ebx+1],1                      │
│a[2]=2;           │mov byte ptr [ebx+2],2                      │
│a[3]=3;           │mov byte ptr [ebx+3],3                      │
│a[4]=4;           │mov byte ptr [ebx+4],4                      │
│a[5]=5;           │mov byte ptr [ebx+5],5                      │
└──────────────────┴────────────────────────────────────────────┘
mov ~ ptr ds:[reg+offset], data
저거 말고
mov ecx, 0
mov byte ptr [ecx+402000], cl
inc ecx
mov byte ptr [ecx+402000], cl
이런식으로 offset을 고정으로 하고 ecx의 값을 1씩 늘려가며 데이터를 넣을 수도 있음

그리고 int 형의 경우 4byte씩 증가하기 때문에
mov dword ptr [ecx*4+402000], eax
이런식으로 곱하기 4를 해줌(4byte 형식이기 때문에 dword, eax로 씀)


[간접주소지정을 이용한 pointer]
┌──────────────────┬────────────────────────────────────────────┐
│        C         │                  Assembly                  │
├──────────────────┼────────────────────────────────────────────┤
│int a = 0;        │mov dword ptr [402000], 0                   │
│int *p = &a;      │mov dowrd ptr [402004], 402000              │
│*p = 4;           │mov ebx, [402004]                           │
│                  │mov dword ptr [ebx], 4                      │
└──────────────────┴────────────────────────────────────────────┘
402000이라는 메모리 주소를 a라는 변수처럼 두고 0을 넣어줌(초기화)
402004에 402000의 주소를 넣음 그리고 레지스터에 그 값을 넘겨주고
4를 넣음(이렇게 하는 이유는 [[402000]]이라고 적을 수 없기 때문)

[cmp]
compare : A와 B를 비교

[jz]->je
jmp equal, jmp zero
jz는 마지막 연산의 결과가 0일때 z(상태 레지스터)의 결과가 참이 되는데(mov 제외)
이때 점프를하는 명령어임(je도 jz랑 같은 명령어)
cmp 연산 결과가 0일 때 z가 참이됨
이유 : cmp는 결과를 비교하기 위해 빼기를 사용하는데 값을 뺀 후에 저장하지 않고 버림
그래서 비교한 레지스터의 값이 그대로 남고 결과값에 대해 플래그를 상태 레지스터에 세팅함
결과값이 0이기 때문에 (eax - 비교값 = 0 = 참) z의 결과가 참이 됨

[jnz]->jne
jmp if not equal, jmp not zero
jnz는 z(상태 레지스터)의 결과가 0일 때 점프하는 명령어
(마지막 연산 결과가 0만 아니면 되는 듯)

[ja, jb]
jmp above:보다 위에
jmp below:보다 아래
cmp 값, 값을 한 뒤에 앞에 수가 크면 ja의 실행조건 작으면 jb의 실행조건 
더 정확히 말하면 c(상태 레지스터)의 값이 0이면 ja실행 1이면 jb실행 조건이 됨
이 때 ja가 실행되려면 z도 0이어야 하는데 그 이유는 z가 1이면 값이 같다는거니
보다 위에라는 것이 말이 되지 않음

[c]
c : carry flag
1111+0001 = 1|0000 이런식으로 범위를 넘어가면 캐리비트가 생성됨
예를 들어 cmp eax, 1이라고 했을 때 eax의 값이 0이면 0-1이 되는데
빼는 수가 더 클경우에도 자리올림이 발생하여 1111111111 이런식으로 되서
c(상태 레지스터)의 값이 0이 된다.
0001 - 1100 = 1|0101 (부호가 있는 2진수 표현에서 1-(-4)) 0101하고 자리올림 1이
발생한 것임 여기서 각각 결과값은 5, c=1로 하지 10101 이런식으로 표현하진 않음

[jna, jnb]->jbe, jae
jmp not above, jmp not below
jmp below equal, jmp above equal
z(상태 레지스터)의 값이 1이거나 c(상태 레지스터)의 값이 1일 경우 jnb의 실행 조건이고,
jna는 z(상태 레지스터)의 값이 1이면서 c(상태 레지스터)의 값이 0이면 실행 조건이 충족됨

┌──────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│    jz    │    jnz   │    ja    │    jb    │    jna   │    jnb   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│   a==b   │   a!=0   │   a>b    │   a<b    │   a<=b   │   a>=b   │
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘
※jmp_flag.txt 참조

[jg, jl]
jmp greater, jmp less
ja와 jb는 부호가 없는 데이터를 비교하지만 jg와 jl은 부호가 있는 데이터를 비교함
ex) 1010은 부호가 없는 절대값이라 하면 10이지만 부호가 있다고 했을 때 -6임
즉 1과 비교한다 했을 때 ja의 조건식으로는 참이지만 jg는 거짓이 됨(실행 안됨)
=부호가 없다고 봤을 때 -4와 1을 비교하면 -4가 더 큼(-4 = FFFFFFFC)

jl은 s(상태 레지스터)의 값과 o(상태 레지스터)의 값이 다를 때 실행됨
이 말은 즉, 최상위 비트가 0(양수)이면서 오버플로우가 일어났거나, 최상위 비트가
1(음수)이면서 오버플로우가 일어나지 않았을 때를 말함
ex) 1111-1111=0000(오버 플로우가 일어나지 않음) 
[s, o]
s : sign flag
o : overflow flg
-4와 1을 비교했을 때 cmp는 빼기를 이용해서 값의 크기를 비교한다 했음
즉 계산결과가 -5가 되어 최상위 비트가 1임 이때 s(상태 레지스터)의 결과가 참이 됨
s는 최상위 비트 즉, 부호를 표현하는 레지스터인데 1111+0001과 같은 경우
10000이 되는데 이때 s=1이 아니라 c=1로 설정되고 s는 맨앞의 1을 c가 가져갔다 생각하고
0을 최상위 비트로 본다.

o(상태 레지스터)는 약간 c와 비슷한데 제대로 설명하자면 c는 최상위 비트에서 자리올림
혹은 빌림이 발생한 경우고 o는 연산 결과가 너무 커서 오버플로우가 발생되는 경우
0111 + 0001 = 1000처럼 양수끼리의 합이 최상위 비트를 건드려 음수처럼 표기가 될
경우 o가 1로 설정됨

[jo, js]
순서가 좀 달라진거 같은데 jo는 o가 참일 때, js(js????)는 s의 값이 참일 때 실행됨

지금까지 j 명령어 정리하자면 e가 붙으면 보통 0포함 n붙으면 부정

[p, a]
p : parity flag
>> intel cpu에서는 기본적으로 홀수 패리티 방식이고, cmp의 결과에서 1의 개수가
짝수가 나오면 패리티를 더해 홀수가 됨으로 p의 값이 1로 세팅됨
ex) eax와 ebx의 값이 같을 때, cmp로 두 값을 비교하면 0이고 패리티 부호를 더해
1이 되어 홀수 패리티 방식에 맞아 p의 결과가 참이됨

a : Auxiliary carry flag
>> 4bit 부호가 없는 정수가 overflow가 발생할 경우 a의 값이 1로 세팅됨
ex) eax와 ebx의 값이 9일 떄, add로 두 값을 더했을 때 알파벳이 아닌 12 이런식으로
나오면 16진수 18인지 10진수 12인지 헷갈릴 수 있음으로 올림이 발생했을 때
보조캐리를 1로 설정함 2진화10진법이라는데 그냥 올림 발생하면 1로 세팅됨

crc32라고 파일을 체크, 오류난 파일복구 등 에러 검출하는 방식으로 패리티를 이용하는데
패리티는 비트에서 1의 개수의 동등성을 지킴
odd parity와 even parity가 있는데 odd parity는 1의 갯수를 패리티까지 세서 홀수가
되도록 유지하고, even parity는 1의 갯수가 패리티 비트까지 해서 짝수가 되도록
유지한다
ex)1100+1로 홀수 패리티인데 1100 -> 1000이 되면 1000+1이 되어 홀수 패리티가
아니게 되어 데이터가 바뀐 것을 감지함
짝수 패리티인 경우는 1100+0 이런식으로 짝수를 맞추고 데이터가 이동하다가 비트가
깨져 1000 이런식으로 바뀌면 1의 갯수가 홀수가 되어 짝수패리티 방식이 무너진 것을
감지함

[adc, sbb]
드디어 jmp 조건에서 벗어남
adc : add cary
ex) mov eax, 8
    add eax, FFFFFFF9
의 식의 연산으로 계산이 1이 되고 carry가 발생함 이렇게 값이 범위를 넘어설때
캐리가 발생하는데 캐리가 발생 했을 때 abc는 값에 캐리를 더해줌
ex) mov eax, 1
    abc eax, 1
eax의 값은 3

쓰는 상황은 4byte를 넘어서 8byte의 연산을 할 때 올림이 발생하면 사용함
ex) mov dword ptr 402000, 2a05f200      //낮은 자리 4byte를 앞에 주소에 넣고
    mov dword ptr 402004, 1             //높은 자리 4byte의 값을 뒤에 넣어줌
    mov dword ptr 402008, 65a0bc00
    mov dword ptr 40200c, 1
    mov eax, 402000         //낮은 자리 4byte씩 연산
    add eax, 402008
    mov 402010, eax         //402010에 낮은 자리수 연산 결과 저장
    mov eax, 402004         //높은 자리 4byte 연산인데 낮은 자리에서 carry가 
    adc eax, 40200c         //발생 했다면, 캐리까지 더해줌(하지만 여기선 아님)
    mov 402014, eax
이런 8byte 연산을 하기 위해 adc가 있음


sbb : sub brrow
ex) mov dword ptr 402000, 20000000      //낮은 자리 4byte를 앞에 주소에 넣고
    mov dword ptr 402004, 2             //높은 자리 4byte의 값을 뒤에 넣어줌
    mov dword ptr 402008, 90000000
    mov dword ptr 40200c, 1
    mov eax, 402000         //낮은 자리 4byte씩 연산
    sub eax, 402008
    mov 402010, eax         //402010에 낮은 자리수 연산 결과 저장
    mov eax, 402004         //높은 자리 4byte 연산인데 낮은 자리에서 빌림이 
    sbb eax, 40200c         //발생 했다면, 그 만큼 빼줌
    mov 402014, eax
빌리는 경우가 발생했으 때 1을 추가로 빼주기 위해 있는 명령어임

만약 adc나 혹은 sbb가 없을 경우 120000000 + 1F0000000의 결과가 210000000이 되고,
220000000 - 190000000 = 190000000 이라는 이상한 결과가 나올 것임

[push, pop]
push : 자료를 넣음
pop : 자료를 뺌
push와 pop은 stack의 자료구조를 가짐
여기서 esp레지스터는 스택의 가장 위에 있는 메모리 주소를 값으로 가지고 있음
그래서 pop을 쓰면 esp에서 주소를 받아오고, esp의 값은 그 밑에 주소를 가르킴
push는 esp를 위로 옮기고 그 곳에 데이터를 저장함(push 한 번에 4byte)

stack 구조를 이용하는 이유는 
void f1(void){
}
void f2(void){
  f1();
}
int main(void) {
  f2();
  f1();
}
처럼 C에서 여러 함수를 호출할 때 stack을 쓰는데
main이 실행시작하면 맨밑에 main이 들어가고, f1이 실행되면 f1이, f2가 실행되면
f2가 순서대로 쌓이고 각각 하나의 호출 된 함수가 끝나면 하나씩 벗겨진다.
ex) main -> f2/main -> f1/f2/main -> f2/main -> main -> f1/main -> main
이런 식으로 그때 그때 실행 종료때마다 push pop을 사용하는 것처럼 진행됨

[mul]
multiplication : (부호가 없는)곱셈 | mul reg/mem
4byte * 4byte = 8byte가 나오는데 한번에 8byte 연산을 못 할 뿐더러 저장할 공간도 없음
따라서 mul 명령어가 실행되는 방식은
mov eax, 4
mov edx, 8
mul edx 를 하면 상위 4byte는 edx 하위 8byte는 eax에 나눠 저장함
(피연산자는 eax로 고정 결과가 담기는 레지스터도 eax, edx 고정)
ex) mov ebx, 2
    mov ecx, 5
    mul ecx를 해도 eax와 ecx를 곱하고, 저장은 eax에 하위 4byte edx에 상위 4byte
2byte 연산일 경우는 ax에 하위 2byte dx에 상위 2bte가 저장되고
1byte 연산일 경우는 ax에만 저장됨

부호가 있는 연산일 경우 곱셈은 결과값이 이상하게 나오기 때문에 제대로 된 연산이 안됨
0101 * 1010 = 01100010은 부호가 있다고 했을 때 50인데
  5  *  -6  =   -30       제대로 된 식이라면 -30이 나와야함
즉, 부호가 있는 곱셈의 경우 값이 이상하게 나와버림

[div]
division : (부호가 없는)나눗셈 | div reg/mem
나눗셈은 피젯수가 eax로 고정되어 있고결과가 몫과 나머지으로 나옴 그래서
8byte의 경우 몫은 eax, 나머지는 edx
4byte의 경우 몫은 ax, 나머지는 dx
2byte의 경우 몫은 al, 나머지는 ah 에 저장됨