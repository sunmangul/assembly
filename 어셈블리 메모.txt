[어셈블리어]
C가 기본으로 되어야함, 어셈블리어는 하드웨어와 가장 가까운 언어로 CPU가 알아먹을 수
있는 언어로 적는 언어, 많은 디버거가 있겠지만 올리디버거를 사용하려 함

[mov]
mov : 값을 덮어씨움
ex) mov reg,(즉시 값)   /   mov reg,reg
입력한 값 또는 다른 레지스터의 값을 레지스터에 덮어 씌움
주소를 넣을 때는 16진수로 들어감 (8자리 4(byte))

[레지스터]
AX : 8(bit)공간 두개
>>AH : 자릿수가 큰쪽 바이트, AL : 자릿수가 작은쪽 바이트

EAX : 8(bit)공간 네개
>>낮은 자리쪽 두 바이트가 AX
그 AX안에서 AH, AL이 똑같이 있음
ex) mov eax, 12D687
AX : D687 | AH : D6 | AL : 87A

E[A,B,C,D]X | [A,B,C,D]X | [A,B,C,D]H | [A,B,C,D]L
요런 것들이 있음

mov 명령어에서 CH와 같이 특정 바이트를 지정해서 값을 넣을 수 있음

[램(RAM)] - 주기억장치
┌───────────┐ ┌─┐                  ┌───────────────┐
│    CPU    │ │R│                  │               │
└───────────┘ │A│                  │               │
              │M│                  │    HARDDISK   │
              └─┘                  │               │
                ┌─┐________________│               │
                └─┘                └───────────────┘
용량 CPU < RAM < HARDDISK
속도 CPU > RAM > HARDDISK
가격 CPU > RAM > HARDDISK

메모리(램)을 주기억장치로 쓰는 이유는 CPU는 잠깐 생각(연산)을 담당하며 하드디스크는
기억한 자료들이 다 저장되긴 하지만 찾아볼 부분이 너무 많아 느림
기억 = CPU, 쪽지 = RAM, 책 = HARDDISK  

[RAM & ROM]
RAM : 읽고 쓰기가 가능한 메모리로 회로 변경이 가능
ROM : 한 번 만들면 회로 변경이 불가능하고 읽는 것만 가능
연결 = 1, 끊김 = 0으로 놓았을 때
    ┌────────────────────┐
   ┌┴─┐                  │
 ┌─┴──┴─┐                │
 │      │          ┌─────┴─────┐
 │      │          │           │
 │      │          │    CPU    │
 │      │          │           │
 │      │          └─────┬┬────┘
 │      │                ││
 └──┬┬──┘                ││
    │└───────────────────┘│
    └───────━   ━─────────┘
와 같이 자릿수에 따라 입력이 가능한데 연결을 끊어[전기 신호를 안줘]서 0을 넣음
이렇게 메모리의 용량을 늘리는데 용량을 늘릴수록 전선의 양이 매우 많이 필요함
(+메모리 핀이 부족함)
이렇기 때문에 주소를 이용하여 값을 전달함(스위치를 이용하여 찾아갈 주소를 지정)
      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0 0 1 0 1
└─────┬┬────┘              │
      │└──────────┐        │
     ┌┴─┐         │        │
   ┌─┴──┴─┐       │        └┐
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 아래 주소만 입력

      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0│0 1 0 1
└─────┬┬────┘              ││
      │└──────────┐         │
     ┌┴─┐         │         │
   ┌─┴──┴─┐       │         │
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 위에 주소만 입력

메모리는 주소하나에 한 바이트의 데이터가 들어가도록 시스템이 설계됨
인텔 32비트 컴퓨터에서는 주소값을 32비트로 표현 가능
=한 바이트를 설정할 수 있는 스위치가 32개 있다=경우의 수 2^32개
=>4GB의 메모리 공간 사용  

[]안에 주소를 써서 메모리 공간 지정(16진수)
mov [402000], al >> MOV BYTE PTR DS:[402000], AL이 됨 -(실행)-> 402000주소 번지에 AL의 값이 들어감
mov cl, [402000] >> MOV AL, BYTE PTR DS:[402000]이 됨 -(실행)-> CL에 402000주소 번지의 값이 들어감
이런식으로 메모리 안에 값을 넣거나 메모리의 값을 레지스터에 넣을 수 있으나 메모리에서 메모리로는 X

= 레지스터에 메모리의 값을 임의로 넣어두고 다른 메모리에 값을 넣어야 함

DWORD PTR DS, WORD PTR DS, BYTE PTR DS
cs:코드 영역, ds : 데이터 영역, es :여분, fs, gs, ss : 세팅 영역
ptr = pointer
DWORD = 4byte WORD=2byte BYTE=1byte (+QWORD = 8byte : 64bit에서 씀)
WORD면 32bit 기본인 4byte가 아닌 이유는 16bit 때부터 써오던 표기라 그대로 2byte로 쓰고, double word인
DWORD라는 4byte 공간이 있음

메모리 지정은 자동이지만 약간 귀찮은 느낌이 있음
ex) 8자리 값(12345678)을 지정할 때, 주소를 2000으로 하면 2007번지부터 12 34 56 78로 들어가서
78 56 34 12로 표기 됨 = 보기 뭔가 이상함

No OPeration(NOP) : 작동하지 않음 = pass

메모리에 레지스터의 값을 넣는게 아니라 직접 넣어줄 때는 메모리 크기 지정이 자동이 아니라 수동으로 해줘야함
만약 402000으로 부터 8자리가 채워져 있었을 경우 mov dword ptr ds:[402000], 0을 해주면
8자리에 0을 채움으로써 앞에 넣었던 값을 모두 0으로 덮어씀

[Byte Ordering [Big Endian/ Little Endian]]
Intel은 한 바이트에 하나의 값을 지정하는 형식을 가지고 있다.
Endian은 하드웨어의 구조, 하드웨어의 설계를 말하는데 데이터 저장 순서에 따라 나뉨
00 01 01 00를 입력을 했을 때
Little Endian의 경우 낮은 자리 수 부터 저장하여 00101000으로 저장됨
Big Endian의 경우 큰 자리 수 부터 저장하여 00010100으로 저장된다.
ex) 3456을 2진수로 바꾸면 0011 0100 0101 0110이고 이것을 낮은 자리 수부터 넣으면
0110 1010 0010 1100 이런식으로 저장됨
메모리는 항상 낮은 자리에서 높은 자리로 실행
읽는다 = 메모리의 데이터를 레지스터로 옮김
Big Endian은 메모리에 적힌 값을 앞에서부터 읽어 높은 자리수에 순서대로 넣음
Little Endian의 경우 맨 앞의 값이 낮은 자리이기 때문에 낮은 자리수부터 넣음
※주소와 자리수를 햇갈리면 안됨

ex) Big Endian 0011010001010110 -> 0011010001010110
 Little Endian 0101011000110100 -> 0011010001010110

그리고 Little Endian 방식으로 저장을 하고 한 바이트씩 끊어 읽기 때문에
01101010/00101100 -> 01010110/00110100 -(10진수)-> 56/34로 메모리에 들어감

Endian 방식은 메모리에 적히는 건 다르지만 읽히고 난 값은 같음

장점 :
Little Endian은 한 바이트씩 기계가 읽기 편하고, 값이 앞에 들어갈 때 메모리 뒤쪽에
써주면 되서 편함
ex) 1234 저장 3412 -> 4321 앞에 추가 34122143 이런식으로 앞에 값이 추가되도
뒤에 넣기 편함 (CPU한테 유리)

Big Endian은 사람이 읽기 편함

[jmp]
jmp : 원하는 주소로 앞이든 뒤든 건너뛰기 가능
EIP : 실행할 곳의 주소를 담고 있는 레지스터(범용 레지스터가 아니라서 mov 사용 안됨)
>> jmp를 이용하여 바꾸게 됨

┌───────────┐ ┌─┐
│401000 EIP │ │R│
└───────────┘ │A│
              │M│
              └─┘ 
401000을 RAM에 넘겨줌 그럼 램은 B8 00000000을 읽어옴 -> 읽어온 바이트만큼 주소값 증가
401005가 되고 한번 더 읽으면 40100A, 40100F 이런식으로 계속 읽어옴
이때 jmp 401005를 실행하면 EB F4를 읽어옴 현재 40100F라고 했을 때, 401011이 됨 그리고
EB F4를 실행되고 입력한 값인 401005번지로 이동하게 된다.
F4 -(2진수)-> 11110100 -(부호가 있는 16진수)-> -C
401011 -C = 401005

-128 ~ +127의 거리를 이동할때는 short이 붙지만 그 이상일 때는 long을 씀

jmp eax와 같은 명령어를 실행할 때는 eax값이 유효한 번지의 값이어야하고
ax처럼 2byte값으로 점프를 하면 메모리에 할당 된 값이 아니라 오류가 생기고 종료됨
메모리 값에 주소를 지정하고 그 메모리 값을 참조하여 점프하는 것도 가능
ex)MOV DWORD PTR DS:[402000],00401015
   JMP DWORD PTR DS:[402000]

[inc, dec]
드디어 증감 연산이 나옴
increment : 증가
decrement : 감소
inc reg/mem, dec reg/mem