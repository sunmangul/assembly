[어셈블리어]
C가 기본으로 되어야함, 어셈블리어는 하드웨어와 가장 가까운 언어로 CPU가 알아먹을 수
있는 언어로 적는 언어, 많은 디버거가 있겠지만 올리디버거를 사용하려 함

[mov]
mov : 값을 덮어씨움
ex) mov reg,(즉시 값)   /   mov reg,reg
입력한 값 또는 다른 레지스터의 값을 레지스터에 덮어 씌움
주소를 넣을 때는 16진수로 들어감 (8자리 4(byte))

[레지스터]
AX : 8(bit)공간 두개
>>AH : 자릿수가 큰쪽 바이트, AL : 자릿수가 작은쪽 바이트

EAX : 8(bit)공간 네개
>>낮은 자리쪽 두 바이트가 AX
그 AX안에서 AH, AL이 똑같이 있음
ex) mov eax, 12D687
AX : D687 | AH : D6 | AL : 87A

E[A,B,C,D]X | [A,B,C,D]X | [A,B,C,D]H | [A,B,C,D]L
요런 것들이 있음

mov 명령어에서 CH와 같이 특정 바이트를 지정해서 값을 넣을 수 있음

[램(RAM)] - 주기억장치
┌───────────┐ ┌─┐                  ┌───────────────┐
│    CPU    │ │R│                  │               │
└───────────┘ │A│                  │               │
              │M│                  │    HARDDISK   │
              └─┘                  │               │
                ┌─┐________________│               │
                └─┘                └───────────────┘
용량 CPU < RAM < HARDDISK
속도 CPU > RAM > HARDDISK
가격 CPU > RAM > HARDDISK

메모리(램)을 주기억장치로 쓰는 이유는 CPU는 잠깐 생각(연산)을 담당하며 하드디스크는
기억한 자료들이 다 저장되긴 하지만 찾아볼 부분이 너무 많아 느림
기억 = CPU, 쪽지 = RAM, 책 = HARDDISK  

[RAM & ROM]
RAM : 읽고 쓰기가 가능한 메모리로 회로 변경이 가능
ROM : 한 번 만들면 회로 변경이 불가능하고 읽는 것만 가능
연결 = 1, 끊김 = 0으로 놓았을 때
    ┌────────────────────┐
   ┌┴─┐                  │
 ┌─┴──┴─┐                │
 │      │          ┌─────┴─────┐
 │      │          │           │
 │      │          │    CPU    │
 │      │          │           │
 │      │          └─────┬┬────┘
 │      │                ││
 └──┬┬──┘                ││
    │└───────────────────┘│
    └───────━   ━─────────┘
와 같이 자릿수에 따라 입력이 가능한데 연결을 끊어[전기 신호를 안줘]서 0을 넣음
이렇게 메모리의 용량을 늘리는데 용량을 늘릴수록 전선의 양이 매우 많이 필요함
(+메모리 핀이 부족함)
이렇기 때문에 주소를 이용하여 값을 전달함(스위치를 이용하여 찾아갈 주소를 지정)
      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0 0 1 0 1
└─────┬┬────┘              │
      │└──────────┐        │
     ┌┴─┐         │        │
   ┌─┴──┴─┐       │        └┐
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 아래 주소만 입력

      ┌───\8─────┐
┌─────┴─────┐    │
│           │    ├ 1 0 0 1 0 1 1 0 1
│    CPU    │    │          │
│           │    └ 0 1 1 1 0│0 1 0 1
└─────┬┬────┘              ││
      │└──────────┐         │
     ┌┴─┐         │         │
   ┌─┴──┴─┐       │         │
   │      │       │         │
   │      │       │         │
   │      │       │         │
   │      │       └──────── ○ (스위치)
   │      │                 │
   │      │                 │
   └───┬──┘                 │
       └────────────────────┘ 의 경우 위에 주소만 입력

메모리는 주소하나에 한 바이트의 데이터가 들어가도록 시스템이 설계됨
인텔 32비트 컴퓨터에서는 주소값을 32비트로 표현 가능
=한 바이트를 설정할 수 있는 스위치가 32개 있다=경우의 수 2^32개
=>4GB의 메모리 공간 사용  

[]안에 주소를 써서 메모리 공간 지정(16진수)
mov [402000], al >> MOV BYTE PTR DS:[402000], AL이 됨 -(실행)-> 402000주소 번지에 AL의 값이 들어감
mov cl, [402000] >> MOV AL, BYTE PTR DS:[402000]이 됨 -(실행)-> CL에 402000주소 번지의 값이 들어감
이런식으로 메모리 안에 값을 넣거나 메모리의 값을 레지스터에 넣을 수 있으나 메모리에서 메모리로는 X

= 레지스터에 메모리의 값을 임의로 넣어두고 다른 메모리에 값을 넣어야 함

[잡다한 문법]
DWORD PTR DS, WORD PTR DS, BYTE PTR DS
cs:코드 영역, ds : 데이터 영역, es :여분, fs, gs, ss : 세팅 영역
ptr = pointer
DWORD = 4byte WORD=2byte BYTE=1byte (+QWORD = 8byte : 64bit에서 씀)
WORD면 32bit 기본인 4byte가 아닌 이유는 16bit 때부터 써오던 표기라 그대로 2byte로 쓰고, double word인
DWORD라는 4byte 공간이 있음

메모리 지정은 자동이지만 약간 귀찮은 느낌이 있음
ex) 8자리 값(12345678)을 지정할 때, 주소를 2000으로 하면 2007번지부터 12 34 56 78로 들어가서
78 56 34 12로 표기 됨 = 보기 뭔가 이상함

No OPeration(NOP) : 작동하지 않음 = pass

메모리에 레지스터의 값을 넣는게 아니라 직접 넣어줄 때는 메모리 크기 지정이 자동이 아니라 수동으로 해줘야함
만약 402000으로 부터 8자리가 채워져 있었을 경우 mov dword ptr ds:[402000], 0을 해주면
8자리에 0을 채움으로써 앞에 넣었던 값을 모두 0으로 덮어씀

[Byte Ordering [Big Endian/ Little Endian]]
Intel은 한 바이트에 하나의 값을 지정하는 형식을 가지고 있다.
Endian은 하드웨어의 구조, 하드웨어의 설계를 말하는데 데이터 저장 순서에 따라 나뉨
00 01 01 00를 입력을 했을 때
Little Endian의 경우 낮은 자리 수 부터 저장하여 00101000으로 저장됨
Big Endian의 경우 큰 자리 수 부터 저장하여 00010100으로 저장된다.
ex) 3456을 2진수로 바꾸면 0011 0100 0101 0110이고 이것을 낮은 자리 수부터 넣으면
0110 1010 0010 1100 이런식으로 저장됨
메모리는 항상 낮은 자리에서 높은 자리로 실행
읽는다 = 메모리의 데이터를 레지스터로 옮김
Big Endian은 메모리에 적힌 값을 앞에서부터 읽어 높은 자리수에 순서대로 넣음
Little Endian의 경우 맨 앞의 값이 낮은 자리이기 때문에 낮은 자리수부터 넣음
※주소와 자리수를 햇갈리면 안됨

ex) Big Endian 0011010001010110 -> 0011010001010110
 Little Endian 0101011000110100 -> 0011010001010110

그리고 Little Endian 방식으로 저장을 하고 한 바이트씩 끊어 읽기 때문에
01101010/00101100 -> 01010110/00110100 -(10진수)-> 56/34로 메모리에 들어감

Endian 방식은 메모리에 적히는 건 다르지만 읽히고 난 값은 같음

장점 :
Little Endian은 한 바이트씩 기계가 읽기 편하고, 값이 앞에 들어갈 때 메모리 뒤쪽에
써주면 되서 편함
ex) 1234 저장 3412 -> 4321 앞에 추가 34122143 이런식으로 앞에 값이 추가되도
뒤에 넣기 편함 (CPU한테 유리)

Big Endian은 사람이 읽기 편함

[jmp]
jmp : 원하는 주소로 앞이든 뒤든 건너뛰기 가능
EIP : 실행할 곳의 주소를 담고 있는 레지스터(범용 레지스터가 아니라서 mov 사용 안됨)
>> jmp를 이용하여 바꾸게 됨

┌───────────┐ ┌─┐
│401000 EIP │ │R│
└───────────┘ │A│
              │M│
              └─┘ 
401000을 RAM에 넘겨줌 그럼 램은 B8 00000000을 읽어옴 -> 읽어온 바이트만큼 주소값 증가
401005가 되고 한번 더 읽으면 40100A, 40100F 이런식으로 계속 읽어옴
이때 jmp 401005를 실행하면 EB F4를 읽어옴 현재 40100F라고 했을 때, 401011이 됨 그리고
EB F4를 실행되고 입력한 값인 401005번지로 이동하게 된다.
F4 -(2진수)-> 11110100 -(부호가 있는 16진수)-> -C
401011 -C = 401005

-128 ~ +127의 거리를 이동할때는 short이 붙지만 그 이상일 때는 long을 씀

jmp eax와 같은 명령어를 실행할 때는 eax값이 유효한 번지의 값이어야하고
ax처럼 2byte값으로 점프를 하면 메모리에 할당 된 값이 아니라 오류가 생기고 종료됨
메모리 값에 주소를 지정하고 그 메모리 값을 참조하여 점프하는 것도 가능
ex) MOV DWORD PTR DS:[402000],00401015
    JMP DWORD PTR DS:[402000]

[증감 연산]
드디어 증감 연산이 나옴
increment(inc) : 증가
decrement(dec) : 감소
ex) inc reg/mem, dec reg/mem
지정해준 레지스터나 메모리의 값이 1씩 증감

addition(add) : 더하기
subtraction(sub) : 빼기
ex) add a, 10 & sub a, 10 (10진수 십이 아니라 16진수 일영임)
add reg/meme, reg/meme & sub reg/mem, reg/mem

[간접주소지정]
mov eax, 402000   //eax에 402000이란 값을 넣음
mov [eax], 0      //[]는 메모리 지정 방식임 거기에 eax가 들어오니까 레지스터의 값에
있는 메모리 주소를 가져옴
혹은
mov dword ptf [402000], 402004
이와 같은 방법을 쓰는 이유는 메모리간 데이터 이동이 불가능하기 때문에 주소를
데이터 형태로 지정하여 이동

offset : 처음 주어진 요소나 지점까지의 변위칠를 나타내는 정수(상대주소)
[고정주소 + 상대주소 + index * scale] 이런식으로도 쓸 수 있고 오프셋 가장 기본은
[고정주소 + 상대주소]같은 형식
여기에 들어갈 수 있는 최대 레지스터는 2개고 index는 반드시 레지스터여야함
scale은 자료형을 나타내는 것으로 int형(4byte)일 경우 scale은 4같은 형식

┌──────────────────┬────────────────────────────────────────────┐
│        C         │                  Assembly                  │
├──────────────────┼────────────────────────────────────────────┤
│char a[6] = 0;    │mov ebx, 402000                             │
│a[0]=0;           │mov byte ptr [ebx],0                        │
│a[1]=1;           │mov byte ptr [ebx+1],1                      │
│a[2]=2;           │mov byte ptr [ebx+2],2                      │
│a[3]=3;           │mov byte ptr [ebx+3],3                      │
│a[4]=4;           │mov byte ptr [ebx+4],4                      │
│a[5]=5;           │mov byte ptr [ebx+5],5                      │
└──────────────────┴────────────────────────────────────────────┘
mov ~ ptr ds:[reg+offset], data
저거 말고
mov ecx, 0
mov byte ptr [ecx+402000], cl
inc ecx
mov byte ptr [ecx+402000], cl
이런식으로 offset을 고정으로 하고 ecx의 값을 1씩 늘려가며 데이터를 넣을 수도 있음

그리고 int 형의 경우 4byte씩 증가하기 때문에
mov dword ptr [ecx*4+402000], eax
이런식으로 곱하기 4를 해줌(4byte 형식이기 때문에 dword, eax로 씀)


[간접주소지정을 이용한 pointer]
┌──────────────────┬────────────────────────────────────────────┐
│        C         │                  Assembly                  │
├──────────────────┼────────────────────────────────────────────┤
│int a = 0;        │mov dword ptr [402000], 0                   │
│int *p = &a;      │mov dowrd ptr [402004], 402000              │
│*p = 4;           │mov ebx, [402004]                           │
│                  │mov dword ptr [ebx], 4                      │
└──────────────────┴────────────────────────────────────────────┘
402000이라는 메모리 주소를 a라는 변수처럼 두고 0을 넣어줌(초기화)
402004에 402000의 주소를 넣음 그리고 레지스터에 그 값을 넘겨주고
4를 넣음(이렇게 하는 이유는 [[402000]]이라고 적을 수 없기 때문)

[cmp]
compare : A와 B를 비교

[jz]->je
jmp equal, jmp zero
jz는 마지막 연산의 결과가 0일때 z(상태 레지스터)의 결과가 참이 되는데(mov 제외)
이때 점프를하는 명령어임(je도 jz랑 같은 명령어)
cmp가 결과가 참일 때 z가 참이됨
이유 : cmp는 결과를 비교하기 위해 빼기를 사용하는데 값을 뺀 후에 저장하지 않고 버림
그래서 비교한 레지스터의 값이 그대로 남고 결과값에 대해 플래그를 상태 레지스터에 세팅함
결과값이 0이기 때문에 (eax - 비교값 = 0 = 참) z의 결과가 참이 됨

[jnz]->jne
jmp if not equal, jmp not zero
jnz는 z(상태 레지스터)의 결과가 0일 때 점프하는 명령어
(마지막 연산 결과가 0만 아니면 되는 듯)

[ja, jb]
jmp above:보다 위에
jmp below:보다 아래
cmp 값, 값을 한 뒤에 앞에 수가 크면 ja의 실행조건 작으면 jb의 실행조건 
더 정확히 말하면 c(상태 레지스터)의 값이 0이면 ja실행 1이면 jb실행 조건이 됨
이 때 ja가 실행되려면 z도 0이어야 하는데 그 이유는 z가 1이면 값이 같다는거니
보다 위에라는 것이 말이 되지 않음

c(상태 레지스터)
carry 1111+0001 = 1|0000 이런식으로 범위를 넘어가면 캐리비트가 생성됨
예를 들어 cmp eax, 1이라고 했을 때 eax의 값이 0이면 0-1이 되는데
빼는 수가 더 클경우에도 자리올림이 발생하여 1111111111 이런식으로 되서
c(상태 레지스터)의 값이 0이 된다.

[jna, jnb]->jbe, jae
jmp not above, jmp not below
jmp below equal, jmp above equal
z(상태 레지스터)의 값이 1이거나 c(상태 레지스터)의 값이 1일 경우 jnb의 실행 조건이고,
jna는 z(상태 레지스터)의 값이 1이면서 c(상태 레지스터)의 값이 0이면 실행 조건이 충족됨

┌──────────┬──────────┬──────────┬──────────┬──────────┬──────────┐
│    jz    │    jnz   │    ja    │    jb    │    jna   │    jnb   │
├──────────┼──────────┼──────────┼──────────┼──────────┼──────────┤
│   a==b   │   a!=0   │   a>b    │   a<b    │   a<=b   │   a>=b   │
└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘
